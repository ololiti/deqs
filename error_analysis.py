# -*- coding: utf-8 -*-
"""Error_Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YovIpgliCZU1vmilkVFrllSA_L28r1vZ
"""

import torch
import numpy as np
from torch.utils.data import DataLoader
import deqmodel
import basemodel
import repeatedmodel
from generate_data import generate_test_data, decoder, generate_biased_data
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt

device = "cuda" if torch.cuda.is_available() else "cpu"

data = generate_test_data()
mydataloader = DataLoader(data, batch_size=len(data))
for feats, labels in mydataloader:
    X = feats.to(device).float()
    y = labels.to(device).float()

base_state = torch.load('basemodel_exp2.pth')
base = basemodel.NeuralNetwork().to(basemodel.device)
base.load_state_dict(base_state)
base.eval()
with torch.no_grad():
    pred, hidden = base(X)

bool_arr = pred > 0
prediction = torch.Tensor([1 if x else 0 for x in bool_arr]).to(device)

def stats(X, y, pred):
    tp, tn, fp, fn = 0, 0, 0, 0
    fp_expr, fn_expr = [], []
    for i in range(len(y)):
        if pred[i] == 1:
            if pred[i] == y[i]:
                tp += 1
            else:
                fp += 1
                fp_expr.append(decoder(X[i]))
        else:
            if pred[i] == y[i]:
                tn += 1
            else:
                fn += 1
                fn_expr.append(decoder(X[i]))
    cf_matrix = np.array([[tn, fp], [fn, tp]])
    return cf_matrix, fp_expr, fn_expr

def getStats(modeltype, data):
    
    mydataloader = DataLoader(data, batch_size=len(data))
    for feats, labels in mydataloader:
        X = feats.to(device).float()
        y = labels.to(device).float()
    name = modeltype.__name__
    state = torch.load(f"{name}_exp2.pth")
    if 'basemodel' in name:
        print('this works')
        model = basemodel.NeuralNetwork().to(modeltype.device)
        model.load_state_dict(state)
        model.eval()
        with torch.no_grad():
            pred, hidden = model(X)
    elif 'repeatedmodel' in name:
        model = repeatedmodel.NeuralNetwork().to(modeltype.device)
        model.load_state_dict(state)
        model.eval()
        with torch.no_grad():
            pred, hidden = model(X)
    elif 'deqmodel' in name:
        model = deqmodel.NeuralNetwork().to(modeltype.device)
        model.load_state_dict(state)
        model.eval()
        with torch.no_grad():
            pred = model(X)
        
               
    bool_arr = pred > 0
    prediction = torch.Tensor([1 if x else 0 for x in bool_arr]).to(device)
    return stats(X,y, prediction)

# cf_matrix, fpx, fnx = getStats(repeatedmodel, data)
cf_matrix1, fpx1, fnx1 = getStats(basemodel, data)
cf_matrix2, fpx2, fnx2 = getStats(deqmodel, data)

fpx2

def getMetric(cf):
    precision = cf[1,1]/(cf[1,1] + cf[0,1])
    recall = cf[1,1]/(cf[1,1] + cf[1,0])
    return precision, recall
def plot_confusion_matrix(cf_matrix, title):
    ax = sns.heatmap(cf_matrix, annot=True, cmap='Blues')
    sns.set(font_scale=1.25)
    ax.set_title(title);
    ax.set_xlabel('Predicted Values')
    ax.set_ylabel('Actual Values ');

    ## Ticket labels - List must be in alphabetical order
    ax.xaxis.set_ticklabels(['False','True'])
    ax.yaxis.set_ticklabels(['False','True'])

    ## Display the visualization of the Confusion Matrix.
    plt.show()

plot_confusion_matrix(cf_matrix1, "Base Model Confusion Matrix")
precision, recall = getMetric(cf_matrix1)
print(precision, recall)

plot_confusion_matrix(cf_matrix2, "DEQ Confusion Matrix")
precision, recall = getMetric(cf_matrix2)
print(precision, recall)

